## Path to Scoring

We used score_data.py and score_decks.py to simulate Penney’s game and the Humble–Nishiyama game. While both games involve players selecting a sequence of three cards and scanning the deck to determine outcomes, the scripts differ significantly in how they define and count tricks.

In Penney’s game, the winner is the player whose chosen 3-card pattern appears more frequently in the deck. In Humble–Nishiyama, players collect cards each time their sequence appears, and the player with the most cards at the end wins. To evaluate strategy performance, our simulation tests all valid pairings of 3-card sequences, records win and draw counts under both scoring systems, and exports the results to a CSV file.

#Way 1 (score_data.py)

The score_data.py script enforces non-overlapping tricks. When a sequence match is found, the program skips ahead by three cards, preventing those cards from being reused in subsequent matches. For instance, given the deck [0, 1, 0, 1, 0] and Player 1’s sequence [0, 1, 0], only the match at index 0:2 would count; the overlapping sequence at index 2:4 would be ignored. This approach produces mutually exclusive trick counts, and in the card-counting variant, entire 3-card blocks are awarded to the matching player. The intent is to treat each 3-card window as a discrete unit to avoid cards being counted twice. In the code logic, if a match is found, the card index is automatically moved forward by three cards before looking to see if another match is found. Additionally, when scoring, I have functions which score a deck on a single player pattern for a single deck. This was done for simplicity and to test to make sure decks were scored properly for a given sequence. To score a deck on all 56 player sequences, I use a seperate function that builds the 8x8 matrix of player win counts. Within this function, I use my single sequence score function in a for loop of all 56 instances, building the matrix as it goes. Is this the most effecient way, unlikley, but it did allow for more control when testing. 

#Way 2 (score_decks.py)

By contrast, score_decks.py allows overlapping matches. It scans the deck one card at a time, counting every occurrence of a sequence regardless if matches share cards. Using the same deck [0, 1, 0, 1, 0] and sequence [0, 1, 0], both positions 0–2 and 2–4 would be counted, giving Player 1 two tricks. In the Humble–Nishiyama variant implemented here, cards are dynamically allocated to a "pot" or running total as matches occur, rather than being awarded in fixed 3-card chunks. This results in continuous scoring that does not accurately reflect playing the game in real life. 

To compare the two approaches, we ran identical decks through both scripts and analyzed the resulting trick counts and card totals. While the results were reproducable for both variants of the Humble-Nishiyama games, the results did not match for winning by tricks; the overlapping method in score_decks.py tends to inflate counts by reusing shared cards across multiple tricks. While both methods reflect different intuitions about gameplay, the logic in score_data.py more accurately captures the intended mechanics of Penney’s and Humble–Nishiyama: once a sequence is matched, its cards are consumed and cannot contribute to another trick. We will continue to work on the method in score_decks.py as the error lies with the code logic so can be fixed. However more testing needs to be done to figure out exactly where the functions are inflating the score counts. 

To test our scoring methods, run_tests.py will generate a small sample of n decks and the score those n decks using way 1 (score_data.py). Decks and scores are saved as .npy files and a csv file of p1 wins, p2 wins, and ties for each scoring method is also returned. Allowed for me the ensure all decks were scored properly as p1 wins, p2 wins, and ties for each given pattern will sum to n. 


Finally, in results we have two csv files for each respective method to score. The were generated from the same deck so should have identical results but do not because of the issues we discussed with way 2 of scoring. 
